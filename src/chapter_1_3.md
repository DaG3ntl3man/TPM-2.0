# Child key generation using ESAPI

To create a TPM key, you need to configure various parameters that define the type of key (e.g., RSA, ECC), its attributes, and other details.

### **ECC Key Creation**

To create an ECC key,

1. **Define the Key Type**
   - Set the `type` field of the `publicArea` to `TPM2_ALG_ECC` for an ECC key.
   - This indicates that the key is of ECC type.

2. **Specify the Hash Algorithm**
   - Set `nameAlg` to `TPM2_ALG_SHA256`, which is a common hash algorithm used in TPMs for ECC keys.

3. **Set Object Attributes**
   - `TPMA_OBJECT` attributes define the key's properties. For ECC keys, you might set attributes such as:
     - `TPMA_OBJECT_USERWITHAUTH`: The key can be used with user authorization.
     - `TPMA_OBJECT_RESTRICTED`: Indicates the key can only be used with restricted access.
     - `TPMA_OBJECT_SIGN_ENCRYPT`: The key can be used for signing and encryption.
     - `TPMA_OBJECT_SENSITIVEDATAORIGIN`: Indicates the key is generated by TPM, ensuring sensitive data origin.

4. **Specify Key Details**
   - For ECC keys, you need to define the curve ID (e.g., `TPM2_ECC_NIST_P256`) and set the key scheme and KDF (Key Derivation Function) scheme to `TPM2_ALG_NULL`, which means no specific scheme is used.

5. **Set Unique Values**
   - If you need to specify sizes of the X and Y coordinates, use `inPublicEcc.publicArea.unique.ecc.x.size` and `inPublicEcc.publicArea.unique.ecc.y.size`.

Here's a code snippet demonstrating how to configure an ECC key:

```c, runnable
TPM2B_PUBLIC inPublicEcc = {
    .size = sizeof(TPM2B_PUBLIC),
    .publicArea = {
        .type = TPM2_ALG_ECC,
        .nameAlg = TPM2_ALG_SHA256,
        .objectAttributes =
            TPMA_OBJECT_USERWITHAUTH | TPMA_OBJECT_RESTRICTED |
            TPMA_OBJECT_SIGN_ENCRYPT | TPMA_OBJECT_SENSITIVEDATAORIGIN,
        .authPolicy = {
            .size = 0, // No policy
        },
        .parameters.eccDetail = {
            .symmetric = {
                .algorithm = TPM2_ALG_NULL,
            },
            .scheme = {
                .scheme = TPM2_ALG_NULL,
            },
            .curveID = TPM2_ECC_NIST_P256,
            .kdf = TPM2_ALG_NULL,
        },
        .unique.ecc = {
            .x.size = 0, // No specific size
            .y.size = 0, // No specific size
        }
    }
};
```

### **RSA Key Creation**

For RSA keys, the setup is slightly different:

1. **Define the Key Type**
   - Set `type` to `TPM2_ALG_RSA`.

2. **Specify the Hash Algorithm**
   - Use `nameAlg` as `TPM2_ALG_SHA256`.

3. **Set Object Attributes**
   - You can use attributes such as:
     - `TPMA_OBJECT_DECRYPT`: The key can be used for decryption.
     - `TPMA_OBJECT_SIGN_ENCRYPT`: The key can be used for signing and encryption.
     - `TPMA_OBJECT_FIXEDTPM`, `TPMA_OBJECT_FIXEDPARENT`, `TPMA_OBJECT_SENSITIVEDATAORIGIN`, etc.

4. **Specify Key Details**
   - Set the key size in `keyBits` and specify the exponent if required. 

Here's a code snippet demonstrating how to configure an RSA key:

```c, runnable
TPM2B_PUBLIC inPublicRsa = {
    .size = sizeof(TPM2B_PUBLIC),
    .publicArea = {
        .type = TPM2_ALG_RSA,
        .nameAlg = TPM2_ALG_SHA256,
        .objectAttributes =
            TPMA_OBJECT_DECRYPT | TPMA_OBJECT_SIGN_ENCRYPT |
            TPMA_OBJECT_FIXEDTPM | TPMA_OBJECT_FIXEDPARENT | TPMA_OBJECT_SENSITIVEDATAORIGIN |
            TPMA_OBJECT_USERWITHAUTH,
        .authPolicy = {
            .size = 0, // No policy
        },
        .parameters.rsaDetail = {
            .symmetric = {
                .algorithm = TPM2_ALG_NULL,
            },
            .scheme = {
                .scheme = TPM2_ALG_NULL,
            },
            .keyBits = 2048, // RSA key size
            .exponent = 0,   // Default exponent
        },
        .unique.rsa = {
            .size = 0, // No specific size
        }
    }
};
```

- **ECC Key**: Set `type` to `TPM2_ALG_ECC`, specify the curve ID and attributes, and optionally set the sizes for X and Y coordinates.
- **RSA Key**: Set `type` to `TPM2_ALG_RSA`, define the key size and exponent, and specify the required attributes.

### How to set up `TPM2B_PUBLIC` structures for ECC and RSA keys?

```C, editable, runnable
// WORKING CODE
/*
 * esapi-template.c
 * 
 * 2024, Dimi Tomov (TPM.dev)
 * 
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This file is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this file. If not, see <https://www.gnu.org/licenses/>.
 */

#include <stdlib.h>
#include <stdio.h>
#include <tss2/tss2_esys.h>
#include <tss2/tss2_tctildr.h>

void print_error(const char* msg, TSS2_RC rc) {
    printf("%s (Error Code: 0x%x)\n", msg, rc);
}

int create_primary_key(ESYS_CONTEXT *ctx, ESYS_TR *pr_handle) {
    TSS2_RC ret;
    
    TPM2B_PUBLIC inPublicPrimary = {
        .size = sizeof(TPM2B_PUBLIC),
        .publicArea = {
            .type = TPM2_ALG_RSA,
            .nameAlg = TPM2_ALG_SHA256,
            .objectAttributes =
                TPMA_OBJECT_DECRYPT | TPMA_OBJECT_SIGN_ENCRYPT |
                TPMA_OBJECT_FIXEDTPM | TPMA_OBJECT_FIXEDPARENT | TPMA_OBJECT_SENSITIVEDATAORIGIN |
                TPMA_OBJECT_USERWITHAUTH,
            .authPolicy = {
                .size = 0,
            },
            .parameters.rsaDetail = {
                .symmetric = {
                    .algorithm = TPM2_ALG_NULL,
                },
                .scheme = {
                    .scheme = TPM2_ALG_NULL,
                },
                .keyBits = 2048,
                .exponent = 0,
            },
            .unique.rsa = {
                .size = 0,
            }
        }
    };

    TPM2B_SENSITIVE_CREATE inSensitivePrimary = {
        .size = sizeof(TPM2B_SENSITIVE_CREATE),
        .sensitive = {
            .userAuth = {.size = 0},
            .data = {.size = 0},
        }
    };

    TPM2B_DATA outsideInfoPrimary = {.size = 0};
    TPML_PCR_SELECTION creationPCRPrimary = {.count = 0};

    TPM2B_PUBLIC *outPublicPrimary = NULL;
    TPM2B_CREATION_DATA *creationDataPrimary = NULL;
    TPM2B_DIGEST *creationHashPrimary = NULL;
    TPMT_TK_CREATION *creationTicketPrimary = NULL;

    ret = Esys_CreatePrimary(
        ctx,
        ESYS_TR_RH_OWNER,
        ESYS_TR_PASSWORD,
        ESYS_TR_NONE,
        ESYS_TR_NONE,
        &inSensitivePrimary,
        &inPublicPrimary,
        &outsideInfoPrimary,
        &creationPCRPrimary,
        pr_handle,
        &outPublicPrimary,
        &creationDataPrimary,
        &creationHashPrimary,
        &creationTicketPrimary
    );

    if (ret != TSS2_RC_SUCCESS) {
        print_error("Error: Esys_CreatePrimary", ret);
        return ret;
    }

    return TSS2_RC_SUCCESS;
}

int main() {
    TSS2_RC ret;
    TSS2_TCTI_CONTEXT *tcti;

    // Initialize TCTI context
    ret = Tss2_TctiLdr_Initialize("mssim:host=127.0.0.1,port=2321", &tcti);
    if (ret != TSS2_RC_SUCCESS) {
        print_error("Error: Tss2_TctiLdr_Initialize", ret);
        return 1;
    }

    // Initialize ESAPI context
    ESYS_CONTEXT *ctx;
    ret = Esys_Initialize(&ctx, tcti, NULL);
    if (ret != TSS2_RC_SUCCESS) {
        print_error("Error: Esys_Initialize", ret);
        Tss2_TctiLdr_Finalize(&tcti);
        return 1;
    }

    // Start TPM
    ret = Esys_Startup(ctx, TPM2_SU_CLEAR);
    if (ret != TSS2_RC_SUCCESS) {
        print_error("Error: Esys_Startup", ret);
        Esys_Finalize(&ctx);
        Tss2_TctiLdr_Finalize(&tcti);
        return 1;
    }

    // Create primary key
    ESYS_TR pr_handle;
    ret = create_primary_key(ctx, &pr_handle);
    if (ret != TSS2_RC_SUCCESS) {
        Esys_Finalize(&ctx);
        Tss2_TctiLdr_Finalize(&tcti);
        return 1;
    }

    // Clean up
    Esys_FlushContext(ctx, pr_handle);
    Esys_Finalize(&ctx);
    Tss2_TctiLdr_Finalize(&tcti);

    return 0;
}
```

### The program upon successfully executing, no error messages will be printed, and the program will exit cleanly.